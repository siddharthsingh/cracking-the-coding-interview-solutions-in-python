class Solution(object):
    def subsets(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]

        SPACE COMPLEXITY
        There are 2^n subsets of a set with 'n' elements. The max size of any subset can be n, so the total space
        required by any algorithm we use will always be equal to or more than O(n*(2^n))

        """
        if not nums: return [[]]
        self.ans = []
        self.store = {}
        a = self.solution1(nums, len(nums))
        ans = [list(x) for x in a]
        ans.append([])

        return ans


    def solution1(self, nums, l):
        """
        This is a recursive function which goes top down and generates output while coming bottom up
        At each level it adds all the elements of the array nums to the previously generated array to
        generate an array of max lenght of subsets +1 than previous
        for example when l == 1, the function will return [[1],[2],[3],[4]]
        for l == 2, it will take the output generated by l==1 and add each element of nums and then union the previous
        result to generate the new result.

        TIME COMPLEXITY


        :param nums: The array of number, or any other element
        :param l: The total length of subset we have to generate
        :return:
        """
        if l in self.store:
            return self.store[l]
        ans = set()
        if l == 1:
            for num in nums:
                ans.add(tuple([num]))
            return ans
        a = self.solution1(nums, l - 1)
        for num in nums:
            for aa in a:
                if num not in aa and len(aa) == l - 1:
                    # we are adding it to a set so it will automatically keep only unique elements
                    # we are sorting because (1,2) is the same as (2,1) (sets are unordered)
                    ans.add(tuple(sorted([num] + list(aa))))
        # union with the previous result, so that the subsets are of length l and l-1
        ans = ans.union(a)
        # self.store[l] = ans
        return ans

    def solution2(self, arr, pos):
        """
        This solution is based on the answer given in book(CTCI). The time complexity is O(n(2^n)).
        According to leetcode, solution1 is little faster than this.
        This is a simple algorithm, in which we have a base case and build up from that. Note that my implementations
        is a little different from the solution from the one given in book. In this solution we have to manually add
        and empty arrar(representing an empty subset) to the answer returned by this function.
        For more details about this solution look at the explanation in book
        :param arr:
        :param pos: The position of the item we are currently adding
        :return:
        """
        if pos == len(arr)-1:
            return [[arr[pos]]]
        ans_from_next_index = self.solution2(arr,pos+1)
        ans = []
        for sub_set in ans_from_next_index:
            ans.append([arr[pos]]+sub_set)
        ans.extend(ans_from_next_index)
        ans.append([arr[pos]])
        return ans
